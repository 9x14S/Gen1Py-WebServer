In gbz80 ASM, the '$' before a number indicates that it is a literal.

The number of bytes that are counter when starting the checksum is 0x0F8B and it is stored
    in the 'bc' register.

'hl' works as the pointer/cursor when reading from the save.
'af' is the general register.
'bc' has the byte count to read.
'd' has the current sum, it is a number between 0 and 255. 'e' isn't used.


The checksum works as follows:

    The 8-bit 'd' register is assigned 0. 

    Then the contents of the address (dereferenced) at 'hl' (16-bit register) are moved into 'a', the 
        main 8-bit register. 
        'hl' here is a pointer that's increased everytime it is dereferenced.
        'hl' always starts at 0xA598.
        In the actual save file, the main data bank starts at 0x2598 and ends at 0x3522, exclusive.
        This is the first instruction in the loop. 
        The address of this instruction is 0x7858 in ROM1C.
        

    The contents at 'd' and 'a' are added together and stored back into 'd'.

    'bc' is decreased by one.

    Then, 'bc' is split into 'b' and 'c', with the contents of 'b' moved into 'a'.
    
    'a' is ORed against 'c', and then a jump if nonzero to the first instruction is called.
    
    If it is zero, then load 'd' into 'a' and complement it (invert its bits).

    Afterwards, return, load 'a' into 'c' (now 'a' is the computed checksum) and the value
        at [$B523] (which I presume is the previous computed checksum) and compare them.

    I've managed to make a prototype that computes the exact checksum in C.